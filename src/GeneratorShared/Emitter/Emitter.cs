using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using PowerEnum.SourceGenerator.Emitter;
using PowerEnum.SourceGenerator.Models;
using System.CodeDom.Compiler;
using System.IO;
using System.Security;
using System.Text;

namespace PowerEnum.SourceGenerator.Generator;

internal static class Emitter
{
    internal static void Emit(in SourceProductionContext context, in EnumDefinition e, in CompilationInfo i)
    {
        var source = EmitSource(e, i);

        var fileName = $"{e.EnumClass.LocalNamespaceAndParentsAndName}.g.cs";

        context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
    }

    private static string EmitSource(in EnumDefinition e, in CompilationInfo i)
    {
        var sw = new StringWriter();
        var iw = new IndentedTextWriter(sw, "    "); /* spaces are better than tabs */

        EmitHeader(iw, i);

        EmitNamespace(iw, e, i);

        EmitPowerEnumNamespace(iw, e, i);

        return sw.ToString();
    }

    private static void EmitHeader(IndentedTextWriter iw, in CompilationInfo i)
    {
        iw.WriteLine("// <auto-generated>");
        iw.WriteLine("//     This code was generated by PowerEnum.");
        iw.WriteLine("//     Modifications to this file will be lost when the code is regenerated.");
        iw.WriteLine("// </auto-generated>");
        iw.WriteLine();

        if (i.HasNullableAnnotations)
        {
            iw.WriteLine("#nullable enable annotations");
            iw.WriteLine("#nullable enable");
            iw.WriteLine();
        }
    }

    private static void EmitNamespace(IndentedTextWriter iw, in EnumDefinition e, in CompilationInfo i)
    {
        if (e.EnumClass.LocalNamespace != null)
        {
            iw.WriteLine($"namespace {e.EnumClass.LocalNamespace}");
            iw.WriteLine("{");
            iw.Indent++;
        }

        EmitNestedTypes(iw, e, i);

        if (e.EnumClass.LocalNamespace != null)
        {
            iw.Indent--;
            iw.WriteLine("}");
        }

        iw.WriteLine();
    }

    private static void EmitNestedTypes(IndentedTextWriter iw, in EnumDefinition e, in CompilationInfo i, int? depth = null)
    {
        if (e.EnumClass.Parents.Length > (depth ?? 0))
        {
            ref readonly var parent = ref e.EnumClass.Parents.AsReadOnlySpan()[depth ?? 0];

            iw.WriteLine($"partial {parent.Keyword} {parent.Name}");
            iw.WriteLine("{");
            iw.Indent++;

            EmitNestedTypes(iw, e, i, (depth ?? 0) + 1);

            iw.Indent--;
            iw.WriteLine("}");
        }
        else
        {
            EmitPartialClass(iw, e, i);
        }
    }

    private static void EmitPartialClass(IndentedTextWriter iw, in EnumDefinition e, in CompilationInfo i)
    {
        iw.WriteLine("[global::System.CodeDom.Compiler.GeneratedCodeAttribute(");
        iw.Indent++;
        iw.WriteLine($@"""{typeof(PowerEnumGenerator).Assembly.FullName}"",");
        iw.WriteLine($@"""{typeof(PowerEnumGenerator).Assembly.GetName().Version}"")]");
        iw.Indent--;

        iw.Write("[global::PowerEnum.Internal.PowerEnumGenerated(");
        iw.Write(SyntaxFactory.Literal(e.SourceFileHash));
        iw.WriteLine(")]");

        if (i.HasSystemTextJsonConverters)
        {
            iw.WriteLine($"[global::System.Text.Json.Serialization.JsonConverterAttribute(");
            iw.Indent++;
            iw.WriteLine($"typeof(global::{e.EnumClass.GeneratedTypesNamespace}.SystemTextJsonConverter)");
            iw.Indent--;
            iw.WriteLine(")]");
        }

        if (i.HasNewtonsoftJsonConverters)
        {
            iw.WriteLine($"[global::Newtonsoft.Json.JsonConverterAttribute(");
            iw.Indent++;
            iw.WriteLine($"typeof(global::{e.EnumClass.GeneratedTypesNamespace}.NewtonsoftJsonConverter)");
            iw.Indent--;
            iw.WriteLine(")]");
        }

        iw.WriteLine($"partial class {e.EnumClass.NameOnly} : global::PowerEnum.IPowerEnum<{e.EnumClass.NameOnly}>");
        iw.WriteLine("{");
        iw.Indent++;

        EmitSharedInternalStruct(iw, e);

        EmitInternalStruct(iw, e, i);
        iw.WriteLine();

        if (e.PartialConstructorVisibility != null)
        {
            EmitPartialConstructor(iw, e, i);
            iw.WriteLine();
        }

        EmitInstanceProperties(iw, e, i);
        iw.WriteLine();

        EmitItems(iw, e, i);
        iw.WriteLine();

        EmitItemsProperty(iw, e, i);
        iw.WriteLine();

        EmitStaticMethods(iw, e, i);
        iw.WriteLine();

        EmitOperatorOverloads(iw, e, i);

        iw.Indent--;
        iw.WriteLine("}");
    }

    private static void EmitSharedInternalStruct(IndentedTextWriter iw, in EnumDefinition e)
    {
        iw.WriteLine($"private class {e.InternalSharedTypeName} : global::PowerEnum.Internal.IPowerEnumInternal");
        iw.WriteLine("{");
        iw.Indent++;

        iw.WriteLine($"public object Items {{ get {{ return {e.InternalStructTypeName}.Items; }} }}");

        iw.Indent--;
        iw.WriteLine("}");
        iw.WriteLine();

        iw.WriteLine($"private static readonly {e.InternalSharedTypeName} {e.InternalSharedMemberName} = new {e.InternalSharedTypeName}();");
        iw.WriteLine();
    }

    private static void EmitInternalStruct(IndentedTextWriter iw, in EnumDefinition e, in CompilationInfo i)
    {
        iw.Write("private struct ");
        iw.WriteLine(e.InternalStructTypeName);
        iw.WriteLine("{");
        iw.Indent++;

        // The struct contains instance data for the enum item that we store.
        // That way we reduce how many names can clash.

        iw.WriteLine("private static int _counter;");
        if (i.HasExpressionBodyPropsMethods)
        {
            iw.WriteLine("public static int Counter => _counter++;");
        }
        else
        {
            iw.WriteLine("public static int Counter { get { return _counter++; } }");
        }
        iw.WriteLine();

        EmitInternalItemsListProperty(iw, e, i);
        iw.WriteLine();

        EmitInternalItemsByNameDictionary(iw, e, i);
        iw.WriteLine();

        EmitInternalItemsByValueDictionary(iw, e, i);
        iw.WriteLine();

        iw.WriteLine("public readonly int _value;");
        iw.WriteLine("public readonly string _name;");
        iw.WriteLine();


        iw.WriteLine($"public {e.InternalStructTypeName}(int counter)");
        iw.WriteLine("{");
        iw.Indent++;

        // Set item values and names
        int index = 0;
        foreach (ref readonly var item in e.ItemNames.AsReadOnlySpan())
        {
            if (index != 0)
            {
                iw.Write("else ");
            }

            iw.WriteLine($"if (counter == {index})");
            iw.WriteLine("{");
            iw.Indent++;

            iw.WriteLine($"_value = {index};");
            iw.Write("_name = ");
            iw.WriteLine($"{SyntaxFactory.Literal(item.Name)};");

            iw.Indent--;
            iw.WriteLine("}");

            index++;
        }

        // only wrap in 'else' block if we actually emitted items...
        if (e.ItemNames.Length > 0)
        {
            iw.WriteLine("else");
            iw.WriteLine("{");
            iw.Indent++;
        }
        var message = $"Additional instances of {e.EnumClass.NameOnly} cannot be created.";
        iw.WriteLine($"throw new global::System.InvalidOperationException({SyntaxFactory.Literal(message)});");
        if (e.ItemNames.Length > 0)
        {
            iw.Indent--;
            iw.WriteLine("}");
        }

        iw.Indent--;
        iw.WriteLine("}");

        if (!i.HasReadonlyAutoImplementedProperties)
        {
            iw.WriteLine();

            foreach (ref readonly var name in e.ItemNames.AsReadOnlySpan())
            {
                if (name.ShouldGenerateProperty)
                {
                    var itemVariable = $"_item_{name.Name}";
                    iw.WriteLine($"public static {e.EnumClass.NameOnly} {itemVariable};");
                }
            }
        }

        // END OF STRUCT
        iw.Indent--;
        iw.WriteLine("}");
        iw.WriteLine();

        iw.WriteLine($"private {e.InternalStructTypeName} {e.InternalStructMemberName} = new {e.InternalStructTypeName}({e.InternalStructTypeName}.Counter);");
        iw.WriteLine();

        if (i.HasExpressionBodyPropsMethods)
        {
            iw.WriteLine($"public int Value => {e.InternalStructMemberName}._value;");
            iw.WriteLine($"public string Name => {e.InternalStructMemberName}._name;");
            iw.WriteLine($"public override string ToString() => {e.InternalStructMemberName}._name;");
        }
        else
        {
            iw.WriteLine($"public int Value {{ get {{ return {e.InternalStructMemberName}._value; }} }}");
            iw.WriteLine($"public string Name {{ get {{ return {e.InternalStructMemberName}._name; }} }}");
            iw.WriteLine($"public override string ToString() {{ return {e.InternalStructMemberName}._name; }}");
        }
        iw.WriteLine();
    }

    private static void EmitInternalItemsListProperty(IndentedTextWriter iw, EnumDefinition e, CompilationInfo i)
    {
        var nullQ = i.HasNullableAnnotations ? "?" : "";
        var nullBang = i.HasNullableAnnotations ? "!" : "";

        var itemsType = $"global::System.Collections.Generic.IReadOnlyList<{e.EnumClass.NameOnly}>";
        iw.WriteLine($"private static {itemsType}{nullQ} _items;");
        iw.Write($"public static {itemsType} Items");

        if (i.HasExpressionBodyPropsMethods)
        {
            iw.WriteLine(" =>");
            iw.Indent++;
        }
        else
        {
            iw.WriteLine();
            iw.WriteLine("{");
            iw.Indent++;
            iw.WriteLine("get");
            iw.WriteLine("{");
            iw.Indent++;
            iw.Write("return ");
        }
        iw.WriteLine("global::System.Threading.LazyInitializer.EnsureInitialized(");
        iw.Indent++;
        iw.WriteLine("ref _items,");

        if (i.HasExpressionBodyPropsMethods)
        {
            iw.Write($"() => ");
            EmitInternalItemsProperty(iw, e, i);
        }
        else
        {
            iw.Write("BuildItemsList");
        }

        iw.WriteLine($"){nullBang};");
        iw.Indent--;
        iw.Indent--;
        if (!i.HasExpressionBodyPropsMethods)
        {
            iw.Indent--;
            iw.WriteLine("}");
            iw.Indent--;
            iw.WriteLine("}");
        }
        iw.WriteLine();

        // Generate the BuildItemsList method if lambdas not being used.
        if (!i.HasExpressionBodyPropsMethods)
        {
            iw.Write("private static ");
            iw.Write(itemsType);
            iw.WriteLine(" BuildItemsList()");
            iw.WriteLine("{");
            iw.Indent++;

            var listType = $"global::System.Collections.Generic.List<{e.EnumClass.NameOnly}>";
            iw.WriteLine($"{listType} items");
            iw.Indent++;
            iw.WriteLine($"= new {listType}();");
            iw.Indent--;
            iw.WriteLine();

            if (e.ItemNames.Length != 0)
            {
                foreach (ref readonly var name in e.ItemNames.AsReadOnlySpan())
                {
                    iw.WriteLine($"items.Add({name.Name});");
                }
            }
            else
            {
                iw.WriteLine("// No items in this enum.");
            }

            iw.WriteLine();

            const string ReadOnlyCollection = "global::System.Collections.ObjectModel.ReadOnlyCollection";
            iw.WriteLine($"return new {ReadOnlyCollection}<{e.EnumClass.NameOnly}>(items);");

            iw.Indent--;
            iw.WriteLine("}");
            iw.WriteLine();
        }
    }

    private static void EmitPartialConstructor(IndentedTextWriter iw, in EnumDefinition e, in CompilationInfo i)
    {
        DocComments.PartialConstructor(iw, e);

        if (e.PartialConstructorVisibility?.Length > 0)
        {
            iw.Write(e.PartialConstructorVisibility);
            iw.Write(' ');
        }

        iw.WriteLine($"partial {e.EnumClass.NameOnly}(");
        iw.Indent++;

        int j = 0;
        foreach (ref readonly var prop in e.Properties.AsReadOnlySpan())
        {
            if (j++ != 0)
            {
                iw.WriteLine(",");
            }
            iw.Write(prop.GlobalQualifiedPropertyType);
            iw.Write(" ");
            iw.Write(prop.PartialConstructorParameterName);
        }

        iw.WriteLine(")");
        iw.Indent--;
        iw.WriteLine("{");
        iw.Indent++;

        foreach (ref readonly var prop in e.Properties.AsReadOnlySpan())
        {
            if (prop.PropertyName == prop.PartialConstructorParameterName)
            {
                iw.Write("this.");
            }
            iw.Write(prop.PropertyName);
            iw.Write(" = ");
            iw.Write(prop.PartialConstructorParameterName);
            iw.WriteLine(";");
        }

        iw.Indent--;
        iw.WriteLine("}");
    }

    private static void EmitInstanceProperties(IndentedTextWriter iw, in EnumDefinition e, in CompilationInfo i)
    {
        if (e.Properties.Length == 0)
        {
            return;
        }

        foreach (ref readonly var property in e.Properties.AsReadOnlySpan())
        {
            if (property.ParamDescription != null)
            {
                iw.WriteLine($"/// <summary>{SecurityElement.Escape(property.ParamDescription)}</summary>");
                iw.WriteLine($"/// <value>Gets the value of the {property.PropertyName} property for this item.</value>");
            }

            iw.Write($"public {property.GlobalQualifiedPropertyType} {property.PropertyName} {{ get; }}");

            if (property.PrimaryConstructorParameterName != null)
            {
                iw.Write($" = {property.PrimaryConstructorParameterName};");
            }

            iw.WriteLine();
        }
    }

    private static void EmitItems(IndentedTextWriter iw, in EnumDefinition e, in CompilationInfo i)
    {
        if (e.ItemNames.Length == 0)
        {
            return;
        }

        int index = 0;
        foreach (ref readonly var name in e.ItemNames.AsReadOnlySpan())
        {
            if (name.ShouldGenerateProperty)
            {
                iw.WriteLine("/// <summary>");
                iw.WriteLine($"/// Gets the item {e.EnumClass.NameOnly}.{name.Name}.");
                iw.WriteLine("/// </summary>");
                iw.WriteLine("/// <value>");
                iw.WriteLine($"/// The {e.EnumClass.NameOnly} instance with name \"{name.Name}\" and value {index}.");
                iw.WriteLine("/// </value>");

                if (i.HasReadonlyAutoImplementedProperties)
                {
                    iw.WriteLine($"public static {e.EnumClass.NameOnly} {name.Name} {{ get; }}");
                }
                else
                {
                    var itemVariable = $"{e.InternalStructTypeName}._item_{name.Name}";

                    iw.WriteLine($"public static {e.EnumClass.NameOnly} {name.Name}");
                    iw.WriteLine("{");
                    iw.Indent++;
                    iw.WriteLine("get");
                    iw.WriteLine("{");
                    iw.Indent++;
                    iw.WriteLine($"return {itemVariable};");
                    iw.Indent--;
                    iw.WriteLine("}");
                    iw.WriteLine($"set");
                    iw.WriteLine("{");
                    iw.Indent++;
                    iw.WriteLine($"if ({itemVariable} != null)");
                    iw.WriteLine("{");
                    iw.Indent++;
                    iw.WriteLine("throw new global::System.InvalidOperationException(");
                    iw.Indent++;
                    iw.WriteLine($"\"{e.EnumClass.NameOnly}.{name.Name} has already been set.\");");
                    iw.Indent--;
                    iw.Indent--;
                    iw.WriteLine("}");
                    iw.WriteLine($"{itemVariable} = value;");
                    iw.Indent--;
                    iw.WriteLine("}");
                    iw.Indent--;
                    iw.WriteLine("}");
                }
            }

            index++;
        }
    }

    private static void EmitItemsProperty(IndentedTextWriter iw, in EnumDefinition e, in CompilationInfo i)
    {
        var readOnlyListType = $"global::System.Collections.Generic.IReadOnlyList<{e.EnumClass.NameOnly}>";

        DocComments.Items(iw, readOnlyListType);
        iw.WriteLine($"public static {readOnlyListType} Items");

        if (i.HasExpressionBodyPropsMethods)
        {
            iw.Indent++;
            iw.WriteLine($"=> {e.InternalStructTypeName}.Items;");
            iw.Indent--;
        }
        else
        {
            iw.WriteLine("{");
            iw.Indent++;
            iw.WriteLine("get");
            iw.WriteLine("{");
            iw.Indent++;
            iw.WriteLine($"return {e.InternalStructTypeName}.Items;");
            iw.Indent--;
            iw.WriteLine("}");
            iw.Indent--;
            iw.WriteLine("}");
        }
    }

    private static void EmitInternalItemsProperty(IndentedTextWriter iw, in EnumDefinition e, in CompilationInfo i)
    {
        if (i.HasImmutableArray)
        {
            const string ImmutableArray = "global::System.Collections.Immutable.ImmutableArray";

            iw.WriteLine($"{ImmutableArray}.Create(");
            iw.Indent++;

            _EmitItemsList(iw, e);

            iw.Write(")");
            iw.Indent--;
        }
        else
        {
            const string ReadOnlyCollection = "global::System.Collections.ObjectModel.ReadOnlyCollection";
            const string List = "global::System.Collections.Generic.List";

            iw.WriteLine($"new {ReadOnlyCollection}<{e.EnumClass.NameOnly}>(");
            iw.Indent++;
            iw.WriteLine($"new {List}<{e.EnumClass.NameOnly}>");
            iw.WriteLine("{");
            iw.Indent++;

            _EmitItemsList(iw, e);
            iw.WriteLine();

            iw.Indent--;
            iw.Write("})");
            iw.Indent--;
        }

        static void _EmitItemsList(IndentedTextWriter iw, EnumDefinition e)
        {
            if (e.ItemNames.Length != 0)
            {
                var itemNames = e.ItemNames.AsReadOnlySpan();
                var first = itemNames[0];
                var remainder = itemNames[1..];

                iw.Write($"{first.Name}");

                foreach (ref readonly var name in remainder)
                {
                    iw.WriteLine(",");
                    iw.Write($"{name.Name}");
                }
            }
            else
            {
                iw.WriteLine("// No items in this enum.");
            }
        }
    }

    private static void EmitInternalItemsByNameDictionary(IndentedTextWriter iw, in EnumDefinition e, in CompilationInfo i)
    {
        const string IReadOnlyDictionary = "global::System.Collections.Generic.IReadOnlyDictionary";
        const string LazyInitializer = "global::System.Threading.LazyInitializer";

        var dictTypeArgs = $"<string, {e.EnumClass.NameOnly}>";
        var nullQ = i.HasNullableAnnotations ? "?" : "";
        var nullBang = i.HasNullableAnnotations ? "!" : "";

        iw.WriteLine($"private static {IReadOnlyDictionary}{dictTypeArgs}{nullQ} _itemsByName;");
        iw.WriteLine($"public static {IReadOnlyDictionary}{dictTypeArgs} ItemsByName");
        iw.WriteLine("{");
        iw.Indent++;
        iw.WriteLine("get");
        iw.WriteLine("{");
        iw.Indent++;

        iw.WriteLine($"return {LazyInitializer}.EnsureInitialized(");
        iw.Indent++;
        iw.WriteLine("ref _itemsByName,");
        iw.WriteLine("delegate");
        iw.WriteLine("{");
        iw.Indent++;

        if (i.HasFrozenDictionary)
        {
            const string FrozenDictionary = "global::System.Collections.Frozen.FrozenDictionary";

            iw.WriteLine($"return {FrozenDictionary}.ToFrozenDictionary(");
            iw.Indent++;
            iw.WriteLine($"Items, delegate({e.EnumClass.NameOnly} item) {{ return item.Name; }});");
            iw.Indent--;
        }
        else
        {
            const string Dictionary = "global::System.Collections.Generic.Dictionary";
            const string ReadOnlyDictionary = "global::System.Collections.ObjectModel.ReadOnlyDictionary";
            var dictionaryType = $"{Dictionary}{dictTypeArgs}";

            iw.WriteLine($"{dictionaryType} dict = new {dictionaryType}(Items.Count);");
            iw.WriteLine();
            iw.WriteLine($"foreach ({e.EnumClass.NameOnly} item in Items)");
            iw.WriteLine("{");
            iw.Indent++;
            iw.WriteLine("dict.Add(item.Name, item);");
            iw.Indent--;
            iw.WriteLine("}");
            iw.WriteLine();

            iw.WriteLine($"return new {ReadOnlyDictionary}{dictTypeArgs}(dict);");
        }

        iw.Indent--;
        iw.WriteLine($"}}){nullBang};");
        iw.Indent--;

        iw.Indent--;
        iw.WriteLine("}");
        iw.Indent--;
        iw.WriteLine("}");
    }

    private static void EmitInternalItemsByValueDictionary(IndentedTextWriter iw, in EnumDefinition e, in CompilationInfo i)
    {
        const string IReadOnlyDictionary = "global::System.Collections.Generic.IReadOnlyDictionary";
        const string LazyInitializer = "global::System.Threading.LazyInitializer";

        var dictTypeArgs = $"<{e.GlobalQualifiedValueType}, {e.EnumClass.NameOnly}>";
        var nullQ = i.HasNullableAnnotations ? "?" : "";
        var nullBang = i.HasNullableAnnotations ? "!" : "";

        iw.WriteLine($"private static {IReadOnlyDictionary}{dictTypeArgs}{nullQ} _itemsByValue;");
        iw.WriteLine($"public static {IReadOnlyDictionary}{dictTypeArgs} ItemsByValue");
        iw.WriteLine("{");
        iw.Indent++;
        iw.WriteLine("get");
        iw.WriteLine("{");
        iw.Indent++;

        iw.WriteLine($"return {LazyInitializer}.EnsureInitialized(");
        iw.Indent++;
        iw.WriteLine("ref _itemsByValue,");
        iw.WriteLine("delegate");
        iw.WriteLine("{");
        iw.Indent++;

        if (i.HasFrozenDictionary)
        {
            const string FrozenDictionary = "global::System.Collections.Frozen.FrozenDictionary";

            iw.WriteLine($"return {FrozenDictionary}.ToFrozenDictionary(");
            iw.Indent++;
            iw.WriteLine($"Items, delegate({e.EnumClass.NameOnly} item) {{ return item.Value; }});");
            iw.Indent--;
        }
        else
        {
            const string Dictionary = "global::System.Collections.Generic.Dictionary";
            const string ReadOnlyDictionary = "global::System.Collections.ObjectModel.ReadOnlyDictionary";
            var dictionaryType = $"{Dictionary}{dictTypeArgs}";

            iw.WriteLine($"{dictionaryType} dict = new {dictionaryType}(Items.Count);");
            iw.WriteLine();
            iw.WriteLine($"foreach ({e.EnumClass.NameOnly} item in Items)");
            iw.WriteLine("{");
            iw.Indent++;
            iw.WriteLine("dict.Add(item.Value, item);");
            iw.Indent--;
            iw.WriteLine("}");
            iw.WriteLine();

            iw.WriteLine($"return new {ReadOnlyDictionary}{dictTypeArgs}(dict);");
        }

        iw.Indent--;
        iw.WriteLine($"}}){nullBang};");
        iw.Indent--;

        iw.Indent--;
        iw.WriteLine("}");
        iw.Indent--;
        iw.WriteLine("}");
    }

    private static void EmitStaticMethods(IndentedTextWriter iw, in EnumDefinition e, in CompilationInfo i)
    {
        var nullQ = i.HasNullableAnnotations ? "?" : "";
        var nullBang = i.HasNullableAnnotations ? "!" : "";

        // FromName
        DocComments.FromName_name(iw);
        iw.WriteLine($"public static {e.EnumClass.NameOnly} FromName(string name)");
        iw.WriteLine("{");
        iw.Indent++;
        {
            iw.WriteLine($"{e.EnumClass.NameOnly}{nullQ} item;");
            iw.WriteLine($"if ({e.InternalStructTypeName}.ItemsByName.TryGetValue(name, out item))");
            iw.WriteLine("{");
            iw.Indent++;
            {
                iw.WriteLine("return item;");
            }
            iw.Indent--;
            iw.WriteLine("}");
            iw.WriteLine();
            iw.WriteLine("throw new global::System.ArgumentException(");
            iw.Indent++;
            iw.WriteLine($"global::System.String.Format(");
            iw.Indent++;
            iw.WriteLine("\"Requested name '{0}' was not found in '{1}'.\",");
            iw.WriteLine(" name,");
            iw.WriteLine($"{SyntaxFactory.Literal(e.EnumClass.NameOnly)}));");
            iw.Indent--;
            iw.Indent--;
        }
        iw.Indent--;
        iw.WriteLine("}");
        iw.WriteLine();

        // TryFromName
        var notNullWhenTrue = i.HasNotNullWhen
            ? "[global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] "
            : "";
        DocComments.TryFromName_name_item(iw);
        iw.WriteLine($"public static bool TryFromName(");
        iw.Indent++;
        iw.WriteLine($"string{nullQ} name,");
        iw.WriteLine($"{notNullWhenTrue}out {e.EnumClass.NameOnly}{nullQ} item)");
        iw.Indent--;
        iw.WriteLine("{");
        iw.Indent++;
        {
            iw.WriteLine("if (string.IsNullOrEmpty(name))");
            iw.WriteLine("{");
            iw.Indent++;
            iw.WriteLine("item = null;");
            iw.WriteLine("return false;");
            iw.Indent--;
            iw.WriteLine("}");

            iw.WriteLine($"return {e.InternalStructTypeName}.ItemsByName.TryGetValue(name, out item);");
        }
        iw.Indent--;
        iw.WriteLine("}");
        iw.WriteLine();

        // FromValue
        DocComments.FromValue_value(iw);
        iw.WriteLine($"public static {e.EnumClass.NameOnly} FromValue({e.GlobalQualifiedValueType} value)");
        iw.WriteLine("{");
        iw.Indent++;
        {
            iw.WriteLine($"{e.EnumClass.NameOnly}{nullQ} item;");
            iw.WriteLine($"if ({e.InternalStructTypeName}.ItemsByValue.TryGetValue(value, out item))");
            iw.WriteLine("{");
            iw.Indent++;
            {
                iw.WriteLine("return item;");
            }
            iw.Indent--;
            iw.WriteLine("}");
            iw.WriteLine();
            iw.WriteLine("throw new global::System.ArgumentException(");
            iw.Indent++;
            iw.WriteLine($"global::System.String.Format(");
            iw.Indent++;
            iw.WriteLine("\"Requested value '{0}' was not found in '{1}'.\",");
            iw.WriteLine(" value,");
            iw.WriteLine($"{SyntaxFactory.Literal(e.EnumClass.NameOnly)}));");
            iw.Indent--;
            iw.Indent--;
        }
        iw.Indent--;
        iw.WriteLine("}");
        iw.WriteLine();

        // TryFromValue
        DocComments.TryFromValue_value_item(iw);
        iw.WriteLine($"public static bool TryFromValue(");
        iw.Indent++;
        iw.WriteLine($"{e.GlobalQualifiedValueType} value,");
        iw.WriteLine($"{notNullWhenTrue}out {e.EnumClass.NameOnly}{nullQ} item)");
        iw.Indent--;
        iw.WriteLine("{");
        iw.Indent++;
        {
            iw.WriteLine($"return {e.InternalStructTypeName}.ItemsByValue.TryGetValue(value, out item);");
        }
        iw.Indent--;
        iw.WriteLine("}");

        // TODO: A parse method which tries by name then by value?
    }

    private static void EmitOperatorOverloads(IndentedTextWriter iw, in EnumDefinition e, in CompilationInfo i)
    {
        DocComments.ValueOperator(iw, e.EnumClass.GlobalQualifiedName, "<");
        iw.WriteLine($"public static bool operator <({e.EnumClass.NameOnly} a, {e.EnumClass.NameOnly} b)");
        iw.WriteLine("{");
        iw.Indent++;
        EmitNullChecks(iw);
        iw.WriteLine("return a.Value < b.Value;");
        iw.Indent--;
        iw.WriteLine("}");
        iw.WriteLine();

        DocComments.ValueOperator(iw, e.EnumClass.GlobalQualifiedName, ">");
        iw.WriteLine($"public static bool operator >({e.EnumClass.NameOnly} a, {e.EnumClass.NameOnly} b)");
        iw.WriteLine("{");
        iw.Indent++;
        EmitNullChecks(iw);
        iw.WriteLine("return a.Value > b.Value;");
        iw.Indent--;
        iw.WriteLine("}");
        iw.WriteLine();

        DocComments.ValueOperator(iw, e.EnumClass.GlobalQualifiedName, "<=");
        iw.WriteLine($"public static bool operator <=({e.EnumClass.NameOnly} a, {e.EnumClass.NameOnly} b)");
        iw.WriteLine("{");
        iw.Indent++;
        EmitNullChecks(iw);
        iw.WriteLine("return a.Value <= b.Value;");
        iw.Indent--;
        iw.WriteLine("}");
        iw.WriteLine();

        DocComments.ValueOperator(iw, e.EnumClass.GlobalQualifiedName, ">=");
        iw.WriteLine($"public static bool operator >=({e.EnumClass.NameOnly} a, {e.EnumClass.NameOnly} b)");
        iw.WriteLine("{");
        iw.Indent++;
        EmitNullChecks(iw);
        iw.WriteLine("return a.Value >= b.Value;");
        iw.Indent--;
        iw.WriteLine("}");

        static void EmitNullChecks(IndentedTextWriter iw)
        {
            iw.WriteLine("if (a == null)");
            iw.WriteLine("{");
            iw.Indent++;
            iw.WriteLine("throw new global::System.ArgumentNullException(nameof(a));");
            iw.Indent--;
            iw.WriteLine("}");
            iw.WriteLine();

            iw.WriteLine("if (b == null)");
            iw.WriteLine("{");
            iw.Indent++;
            iw.WriteLine("throw new global::System.ArgumentNullException(nameof(b));");
            iw.Indent--;
            iw.WriteLine("}");
            iw.WriteLine();
        }
    }

    private static void EmitPowerEnumNamespace(IndentedTextWriter iw, in EnumDefinition e, in CompilationInfo i)
    {
        iw.WriteLine($"namespace {e.EnumClass.GeneratedTypesNamespace}");
        iw.WriteLine("{");
        iw.Indent++;

        if (i.HasSystemTextJsonConverters)
        {
            const string Utf8JsonReader = "global::System.Text.Json.Utf8JsonReader";
            const string Utf8JsonWriter = "global::System.Text.Json.Utf8JsonWriter";
            const string JsonSerializerOptions = "global::System.Text.Json.JsonSerializerOptions";
            const string JsonConverter = "global::System.Text.Json.Serialization.JsonConverter";
            const string Type = "global::System.Type";

            iw.WriteLine($"{e.EnumClass.Visibility} class SystemTextJsonConverter : {JsonConverter}<{e.EnumClass.GlobalQualifiedName}>");
            iw.WriteLine("{");
            iw.Indent++;
            {
                iw.WriteLine($"public override {e.EnumClass.GlobalQualifiedName}{i.NullQ} Read(");
                iw.Indent++;
                iw.WriteLine($"ref {Utf8JsonReader} reader,");
                iw.WriteLine($"{Type} typeToConvert,");
                iw.WriteLine($"{JsonSerializerOptions} options)");
                iw.Indent--;
                iw.WriteLine("{");
                iw.Indent++;
                {
                    iw.WriteLine($"return {e.EnumClass.GlobalQualifiedName}.FromName(reader.GetString() ?? \"\");");
                }
                iw.Indent--;
                iw.WriteLine("}");
                iw.WriteLine();
                iw.WriteLine($"public override void Write(");
                iw.Indent++;
                iw.WriteLine($"{Utf8JsonWriter} writer,");
                iw.WriteLine($"{e.EnumClass.GlobalQualifiedName} value,");
                iw.WriteLine($"{JsonSerializerOptions} options)");
                iw.Indent--;
                iw.WriteLine("{");
                iw.Indent++;
                {
                    iw.WriteLine("writer.WriteStringValue(value.Name);");
                }
                iw.Indent--;
                iw.WriteLine("}");
            }
            iw.Indent--;
            iw.WriteLine("}");
        }

        if (i.HasNewtonsoftJsonConverters)
        {
            const string JsonConverter = "global::Newtonsoft.Json.JsonConverter";
            const string JsonReader = "global::Newtonsoft.Json.JsonReader";
            const string JsonWriter = "global::Newtonsoft.Json.JsonWriter";
            const string JsonSerializer = "global::Newtonsoft.Json.JsonSerializer";
            const string Type = "global::System.Type";

            iw.WriteLine($"{e.EnumClass.Visibility} class NewtonsoftJsonConverter : {JsonConverter}<{e.EnumClass.GlobalQualifiedName}>");
            iw.WriteLine("{");
            iw.Indent++;
            {
                iw.WriteLine($"public override {e.EnumClass.GlobalQualifiedName}{i.NullQ} ReadJson(");
                iw.Indent++;
                iw.WriteLine($"{JsonReader} reader,");
                iw.WriteLine($"{Type} objectType,");
                iw.WriteLine($"{e.EnumClass.GlobalQualifiedName}{i.NullQ} existingValue,");
                iw.WriteLine($"bool hasExistingValue,");
                iw.WriteLine($"{JsonSerializer} serializer)");
                iw.Indent--;
                iw.WriteLine("{");
                iw.Indent++;
                {
                    iw.WriteLine($"return reader.Value == null ? null : {e.EnumClass.GlobalQualifiedName}.FromName(reader.Value.ToString() ?? \"\");");
                }
                iw.Indent--;
                iw.WriteLine("}");
                iw.WriteLine();
                iw.WriteLine($"public override void WriteJson(");
                iw.Indent++;
                iw.WriteLine($"{JsonWriter} writer,");
                iw.WriteLine($"{e.EnumClass.GlobalQualifiedName}{i.NullQ} value,");
                iw.WriteLine($"{JsonSerializer} serializer)");
                iw.Indent--;
                iw.WriteLine("{");
                iw.Indent++;
                {
                    iw.WriteLine("writer.WriteValue(value == null ? null : value.Name);");
                }
                iw.Indent--;
                iw.WriteLine("}");
            }
            iw.Indent--;
            iw.WriteLine("}");
        }

        iw.Indent--;
        iw.WriteLine("}");
        iw.WriteLine();
    }
}
